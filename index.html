<!DOCTYPE html>
<html>
<head>
<link rel="icon" href="favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon"> 
<title>WebRTC Reflector</title>
</head>
<style>
.video_item {
	width: 90%;
	height: auto;
	border-style: solid;
	border-color: red;
	border-width: 2px;
	align-items: center;
	justify-content: center;
    display: flex;
	flex-direction: column;
}

.overlay_item {
    background: #b3e0ff;
	position: absolute;
    width: 25%;
	top: 3%; left: 3%;
    display: none;
    margin: 2px;
	z-index: 2;
}

p {
  margin-top: 2px;
  margin-bottom: 2px;
  font-size: 18px;
  font-family: Arial;
  text-decoration: none;
}

label {
    font-size: 20px;
	font-family: Arial;
}

button {
    margin: 2px;
    background-color: #007acc;
	border-style: solid;
	border-color: black;
	border-width: 1px;
    color: white;
    padding: 10px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 20px;
	font-family: Arial;
}
button:hover {
    box-shadow: 5px 10px 14px #888888;
}
button:active {
    background-color: #004d80;
}


.dropbtn {
  background-color: #3498DB;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
  cursor: pointer;
}

.dropbtn:hover, .dropbtn:focus {
  background-color: #2980B9;
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  overflow: auto;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

.dropdown a:hover {background-color: #ddd;}

.show {display: block;}

</style>
<body onLoad="handleLoading()">
<div id='overlay' class="overlay_item">
<p id='container'>Video Container: --</p>
<p id='rate'>Video Bitrate: --</p>
<p id='frag'>Video Fragment: --</p>
<p id='nettype'>Network Type: --</p>
<p id='downlink'>Downlink Speed: --</p>
<p id='rtt'>Video RTT: --</p>
</div>
<center>
<div class="video_item">
<video id='reflect_video2' width=640 height=480></video>
</div>

<div>
<input type="checkbox" id="mute" name="mute" onclick="handleMute(this);">
<label for="mute">Audio Mute</label>
<div class="dropdown">
  <button onclick="handleSelectMicButton()">Microphone</button>
  <div id="mic_dropdown" class="dropdown-content">
  </div>
</div>
<div class="dropdown">
  <button onclick="handleSelectCameraButton()">Camera</button>
  <div id="camera_dropdown" class="dropdown-content">
  </div>
</div>
<button id="connect" onclick="handleConnect()">Connect</button>
</div>
</center>

<script>
let mediaStream = null;
let mediaRecorder = null;
let mediaSource = null;
let sourceBuffer = null;
const serverUrl = "https://%s:%d/mediaEcho";
let mimeTypeUse = null;
const videoFragSize = %d;
let videoFragCount = 0;
let lastFragNumber = 0;
let lastFragTime = 0;
let browser = "Chrome";
let cameraDevice = [];
let cameraIndex = 0;
let micDevice = [];
let micIndex = 0;
let connected = false;

navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia
URL = window.webkitURL || window.URL;

function getMediaStream()
{ 
	let option = {
		audio: {
			echoCancellation: {exact: true},
			noiseSuppression: {exact: true},
			deviceId: micDevice[micIndex].deviceId,
			groupId: micDevice[micIndex].groupId
		},
		video: {
			deviceId: cameraDevice[cameraIndex].deviceId,
			groupId: cameraDevice[cameraIndex].groupId
		}
	};

    navigator.mediaDevices.getUserMedia(option).then(function(stream) {
	
		if ('connection' in navigator) {
			navigator.connection.onchange = () => {
				updateNetworkStat();
			};
		}
	
	    mediaStream = stream;
				
		if (MediaSource.isTypeSupported('video/webm;codecs="vp9"'))
		    mimeTypeUse = 'video/webm;codecs="vp9"'
        else if (MediaSource.isTypeSupported('video/mp4'))
            mimeTypeUse = 'video/mp4';
		else 
		    console.log("Not found a valid mime type");
		console.log("Supported mime type: ", mimeTypeUse);
		if (browser === 'Firefox')
			mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'video/webm', bitsPerSecond: 1000000 });
		else
			mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'video/webm;codecs="vp9"', bitsPerSecond: 1000000 });
		mediaSource = new MediaSource();
		
		mediaSource.addEventListener("sourceopen", () => {	
			if (mimeTypeUse === 'video/webm;codecs="vp9"')
				sourceBuffer = mediaSource.addSourceBuffer('video/webm;codecs="vp9,opus"')
			else if (mimeTypeUse === 'video/mp4')
				sourceBuffer = mediaSource.addSourceBuffer('video/mp4')
			sourceBuffer.mode = 'sequence';
			sourceBuffer.timestampOffset = 0.0
		});
		
		var video = document.getElementById('reflect_video2');
        video.src = URL.createObjectURL(mediaSource)
		video.muted = document.getElementById("mute").checked
				
        mediaRecorder.addEventListener("dataavailable", event => {
		    //console.log("dataavailable ", event.data);
					    			
			event.data.arrayBuffer().then(b => {				
				let t = new Uint8Array(b)				
				let request = new XMLHttpRequest();
				request.onreadystatechange = () => {
					try {
						if (request.readyState == 4) {
							if (request.status == 200) {
								//console.log("POST response: ", request.response);
								request.response.arrayBuffer().then(b => {

                                    sourceBuffer.addEventListener('updateend', () => { 
										//console.log("Buffer update end")
									});
									
									sourceBuffer.addEventListener('error', () => {
										console.log("Buffer error")
									});
									
									sourceBuffer.appendBuffer(b)
								    let video = document.getElementById('reflect_video2');
									if (video.paused)
										video.play().then(() => {console.log("Play success");}).catch( () => {console.log("Play failed");});
									
								});
								let fragNumber = parseInt(request.getResponseHeader("Pragma"))
								//console.log("fragNumber = ", fragNumber)
								if (lastFragNumber === fragNumber) {
					                let date = new Date();
									document.getElementById('rtt').innerHTML = "Video RTT: " + (date.getTime() - lastFragTime) + " ms"
								}
								request = null;
							}
						}
					} catch (e) {
						console.log("error: " + e.description);
					}
				}
				request.onerror = () => {
					console.log("POST failed");
					stopRecording();
				}
				request.open("POST", serverUrl, true);
				request.setRequestHeader("Content-Type", "application/octet-stream");
				request.setRequestHeader("Pragma", videoFragCount.toString());
				request.responseType = "blob";
				request.send(t);
				lastFragNumber = videoFragCount++;
				let date = new Date();
				lastFragTime = date.getTime();
				document.getElementById('rate').innerHTML = "Video Bitrate: " + (t.length * 8 / (videoFragSize * 1000000)).toFixed(2) + " mbps"
				if ('connection' in navigator)
					console.log(navigator.connection)
				else
					console.log("navigator.connection not supported")
				//console.log(navigator.connection)
			});			
        });
		
		mediaRecorder.addEventListener("error", event => {
			console.log("mediaRecorder error: " + e.description);
		});
		
		mediaRecorder.start(videoFragSize * 1000);
		
		connected = true;
		
		document.getElementById('frag').innerHTML = "Video Fragment: " + videoFragSize + " sec"
		let res = mimeTypeUse.split(";")
		let res2 = res[0].split("/")
		if (res2.length == 2)
			document.getElementById('container').innerHTML = "Video Container: " + res2[1]
		else
			document.getElementById('container').innerHTML = "Video Container: " + res[0]
		updateNetworkStat()
			
    }).catch(error);
}

function error(error) { 
    console.error('error:', error); 
}

function updateNetworkStat() {
	if ('connection' in navigator) {
		//console.log(navigator.connection)
		if ('effectiveType' in navigator.connection)
			document.getElementById('nettype').innerHTML = "Network Type: " + navigator.connection.effectiveType
		if ('downlink' in navigator.connection)
			document.getElementById('downlink').innerHTML = "Downlink Speed: " + navigator.connection.downlink + " mbps"
	} else {
		console.log("navigator.connection not supported")
	}
}

function isPrintable(str) {
	for (let i = 0; i < str.length; i++) {
		const val = str.codePointAt(i);
		if (val > 32 && val < 127)
			return true;
	}
	return false
}

function handleLoading() {
	//console.log(navigator.userAgent)
	let str = navigator.userAgent
	let srtList = str.split(" ");
	let token = srtList[srtList.length - 1]
	browser = token.split("/")[0]
	
	console.log("Browser = ", browser)
	
    navigator.mediaDevices.enumerateDevices().then(function(devices) {
		devices.forEach(function(device) {
			if (device.deviceId !== 'default' && device.deviceId !== 'communications') {
				if (device.kind === 'audioinput') {
					micDevice.push({deviceId: device.deviceId, groupId: device.groupId, label: device.label});
				} else if (device.kind === 'videoinput') {
					cameraDevice.push({deviceId: device.deviceId, groupId: device.groupId, label: device.label});
				}
			}
			//console.log(device);
		});
		console.log("Camera Device = ", cameraDevice.length)
		console.log("Mic Device = ", micDevice.length)
		for (let i = 0; i < cameraDevice.length; i++) {
			let t = cameraDevice[i].label
			if (!isPrintable(t))
				t = "Camera " + i
			document.getElementById('camera_dropdown').innerHTML += '<a onclick="handleSelectCamera(' + i + ')">' + t + '</a>'
		}
		for (let i = 0; i < micDevice.length; i++) {
			let t = micDevice[i].label
			if (!isPrintable(t))
				t = "Microphone " + i
			document.getElementById('mic_dropdown').innerHTML += '<a onclick="handleSelectMic(' + i + ')">' + t + '</a>'
		}

	}).catch(function(err) {
		console.log(err.name + ": " + err.message);
	});
	
	updateNetworkStat();
}

function startRecording() {
	videoFragCount = 0;
	lastFragNumber = 0;
	lastFragTime = 0;
	
	getMediaStream();

    document.getElementById('connect').innerHTML = "Disconnect"
	document.getElementById('overlay').style.display = "inline"
}

function stopRecording() {
	mediaStream.getTracks().forEach(function(track) {
	  track.stop();
	});
	mediaRecorder.stop();
	connected = false;
	document.getElementById('connect').innerHTML = "Connect"
	document.getElementById('reflect_video2').src = ""
	document.getElementById('container').innerHTML = "Video Container: --"
	document.getElementById('frag').innerHTML = "Video Fragment: --"
	document.getElementById('rate').innerHTML = "Video Bitrate: --"
	document.getElementById('rtt').innerHTML = "Video RTT: --"
	document.getElementById('nettype').innerHTML = "Network Type: --"
	document.getElementById('downlink').innerHTML = "Downlink Speed: --"
	document.getElementById('overlay').style.display = "none"
}

function handleConnect() {
	if (!connected) {
		startRecording();
	} else {
		stopRecording();
	}
}

function handleSelectCameraButton() {
  document.getElementById("camera_dropdown").classList.toggle("show");
}

function handleSelectCamera(index) {
  document.getElementById("camera_dropdown").classList.toggle("show");
  cameraIndex = index;
  console.log("Camera selected ", index)
}

function handleSelectMicButton() {
  document.getElementById("mic_dropdown").classList.toggle("show");
}

function handleSelectMic(index) {
  document.getElementById("mic_dropdown").classList.toggle("show");
  micIndex = index;
  console.log("Microphone selected ", index)
}

function handleMute(cb) {
	var video = document.getElementById('reflect_video2');
	video.muted = cb.checked
}

</script>
</body>
</html>